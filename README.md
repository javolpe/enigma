# Enigma

Jake Volpe Turing BE2011

### Functionality 
   For functionality I feel I have met expectations.  I did not get into the cracking class as I spent other time focused on refactoring and dealing with simplecov/rake test things that took me frankly longer than it should have (also some small VCS hiccups).  The way I interpreted the interaction pattern and rubric was that the user should be able to choose whether or not they would like to supply a code and/or a date to encrypt a message of their choosing. However they are never given a chance to do that from the command line.  Therefore the only place a user **could** enter a specific code and date to use is from the message.txt file that contains the message to encrypt.  The way my program is set up is the first line of that .txt file is the message, the second line is the user submitted code to encrypt the message, and the third is the date used to encrypt the message.  If the message.txt file only has two lines and no date is given then today's date is used.  If the message.txt file only has one line and no code AND no date is given then a code is randomly generated and today's date is used.  The limitations of this setup is that the message has to be only one line.  This could easily be refactored to allow for multi-line messages but it is how I set up the encryption up for now.
   
   The only piece of functionality that is slightly different in my project vs the interaction pattern/rubric is the decrypt method taking an optional arguemnt for date within the enigma.decrypt method, though I very much feel I have fulfilled this requirment in the spirit of the project.  The only interaction the user will ever have with the program (aside from creating files to be put in and out of the program) is via the command line and if when going to decrypt the user does not enter a date then a default date of today's date is generated and used (from the runner file).  So from the command line the user has the ability to enter a date, and if no date is entered today's date will be autogenerated to be used. Technically speaking the enigma.decrypt method does require 3 arguments but I have allowed the user the option of entering a date or defaulting to today's date.
   
### Obect Oriented Programming
  I feel I am above expectations here.  All of my code is dynamic and easily and quickly adjusted to be using more of less keys or changing the encryption algorithm.  I have 3 total classes and 1 module.  The enigma class feeds into the encrypting_machine and decrypting_machine class.  The encrypting_machine and decrypting_machine classes each have two methods and share a module called encryption_module that contains 5 methods that are reused by both classes.  My end goal for encoding/decoding was to create 4 hashes where the keys are the alphabet in normal order (plus a space) and the values are the alphabet rotated X amount of times based on the enigma code.  I believe I sacrificed CPU usage for less lines of code written and more dynamic workflow.  
  
  Every time a letter needs to be encoded the CPU determines if that letter is on the ABC or D shift, then it generates a hash of ABCD and 4 integers that represent the rotation for those 4 keys.  Then the specific hash for the appropriate key is made of normal alphabet keys, rotated alphabet values.  That is then passed into a method called encode_letter that checks if the value to be encoded is a key within that hash, if not it returns itself, if it is then the value associated with that letter from the hash is returned. This is done exactly the right amount of times for the letters.  
  
  The only methods not in the module is the method to determine the amount of rotation the alphabet needs and the only difference between the classes is encrypton rotates as a positive integer and the decryption rotates as a negative integer.  Given the same inputs (code and date) they will rotate the same amount just in opposite directions.  THe only difference in encrpyt_the_message and decrypt_the_message is in name.
  
  The module doesn't need to hold any state.  It is simply working with information stored in the instances of the class that utilitze it, hence why it is a module and not a class used for inheritance.  By sharing these methods in the module it makes it easier to adjust how the encryption works and guarantee that both classes will be affected equally.
  
 ### Ruby Conventions and Mechanics
  I feel I have met or exceeded expectations here.  I am hoping that someone who understands how the enigma encryption works could look into this program and understand the flow of what is happening and the why of how it is structured.  If they don't, well, it is an encryption program so I was purposefully trying to make it hard to decipher (sorry, bad joke).  I feel like all my syntax and identing follows Ruby convention, I didn't make any crazy nested methods or super long individual methods.  Time was put into renaming my methods to hopefully ensure that the method name clearly communicates what that method outputs so that it could be understood in the bigger flow of the project.
  
  I do feel the methods are organized in a logical way.  I couldn't put the encrpyt_the_message and decrypt_the_message into the module because I needed a class to hold state and the key_shift_hash had to be different to shift "forwards" or "backwards".  I could have moved that one into the module and then have decrypt override it but at that point it wouldn't really being shared by more than one class and so felt a bit pendantic to move that method into the module.  I did check and I think my longest method is 8 lines.  Felt I did a good job of utilizing helper methods to keep all methods to a reasonable and concise length.
  
### Test Driven Development
  I felt I met expectations here.  Didn't use mocks and stubs although I did finally start to play around with them to mixed results.  When the rake file is run it is at 100%, though I did add it to my .gitignore file so not sure it will show up if the repo is clone down (probably not, that seems to be how gitignore works).  I did write tests before writing my methods but some of them, like encoding letter, I threw into a repl so I could be sure of the expected answer and to verify that my program was working right as well.  Even encrypted/decrypted one by hand to ensure as well.  There definitely was some methods that I wrote an unfinished test for and then started working on the method before finalizing the tests though.  Didn't ever go full Dream Driven Development but getting the method started clarified for me exactly how I wanted the output formulated.
  
Got over 30 commits, (hoefully) logical pull requests, and lessons learned on using git (mainly never do anything locally from main except pull down then immediately switch to a branch you want to work on).
